%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  normal_getGraphCutRegion.m
%
%  Gets the indices of the image to be used during graph cut segmentation
%  for the specified layer
%
%--------------------------------------------------------------------------
%
%  function regionIndices = normal_getGraphCutRegion( ...
%      image, ...
%      layerNumber, ...
%      axialRes, ...
%      eye, ...
%      rpeTop, ...
%      rpeBottom, ...
%      foveaParams, ...
%      layers)
%
%  INPUT PARAMETERS:
%
%       image - A [imageHeight x imageWidth] image to segment
%
%       layerNumber - The layer index to segment
%
%       axialRes - Axial (vertical) resolution of the image in um/pixel
%
%       eye - Which eye was imaged (assuming a 0 degree scan)
%           [1] Left eye
%           [2] Right eye
%
%       rpeTop - A vector of size (1 x imageWidth) estimating the location
%                of the inner aspect of the RPE, generated by the
%                normal_getBwImage() function
%
%       rpeBottom - A vector of size (1 x imageWidth) estimating the 
%                   location of the outer aspect of the RPE, generated by
%                   the normal_getBwImage() function
%
%       foveaParams - A structure containing information about the fovea,
%                     obtained by calling the locateFovea() function
%
%       layers - A [nLayers x imageWidth] matrix where each column contains
%               the y-coordinates of a layer
%
%  RETURN VARIABLES:
%
%       regionIndices - Indices of the image that are in the region to
%                       segment for the specified layer
%
%--------------------------------------------------------------------------
%
%  Author:          Stephanie Chiu
%  Institution:     Duke University
%  Date Created:    2009.12.20
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function regionIndices = normal_getGraphCutRegion( ...
    image, ...
    layerNumber, ...
    axialRes, ...
    eye, ...
    rpeTop, ...
    rpeBottom, ...
    foveaParams, ...
    layers)
    
    
    %----------------------------------------------------------------------
    %  Get the layer parameters if no previous imageLayers were input
    %----------------------------------------------------------------------
    
    if isempty(eye) || (eye ~= 1 && eye ~= 2)
        error('Eye must have a value of 1 or 2');
    end
    
    %----------------------------------------------------------------------
    %  Get the layer parameters if no previous imageLayers were input
    %----------------------------------------------------------------------

    imageSize = size(image);
    imageHeight = imageSize(1);
    imageWidth = imageSize(2);
    
    topLayerAddition = 0;
    bottomLayerAddition = 0;
    correctBottomLine = 0;
        
    switch (layerNumber)

        % vitreous-NFL
        case {1}            
            yTop = ones(1, imageWidth);
            yBottom = rpeTop;
            correctBottomLine = 1;

        % cut RPE-Choroid
        case {8}
            if all(isnan(layers(8,:))) 
                if all(isnan(rpeTop))
                    yTop = layers(1,:) + round(100.5/axialRes);
                else
                    yTop = rpeTop;
                end
                yBottom = rpeBottom;
            else
                yTop = layers(8,:) + round(13.4/axialRes);
                yBottom = layers(8,:) + round(67/axialRes);
            end

        % cut OS-RPE
        case {7}
            yTop = layers(8,:) - round(33.5/axialRes);
            yBottom = layers(8,:) - round(13.4/axialRes);

        % cut IS-OS
        case {6}
            yTop = layers(7,:) - round(67/axialRes);
            yBottom = layers(7,:) - round(20.1/axialRes);
            
        % cut 
        case {4}
            if all(isnan(layers(5,:)))
                difference = layers(6,:) - layers(1,:);
                yTop1 = layers(1,:) + round(difference/3);
                yTop2 = layers(6,:) - round(134/axialRes);
                yTop3 = layers(1,:) + round(13.4/axialRes);
                yTop = nanmax(nanmin(yTop1,yTop2),yTop3);
                yBottom = layers(6,:) - round(40.2/axialRes);
            else
                yTop = layers(3,:);
                yBottom = layers(5,:);
                correctBottomLine = 1;
            end

        % cut 
        case {3}
            yTop = layers(4,:) - round(46.9/axialRes);
            yBottom = layers(4,:);
            
        % cut 
        case {5}
            yTop = round(smooth(layers(4,:),0.1)');
            yBottom1 = yTop + round(100.5/axialRes);
            yBottom2 = layers(6,:) - round(13.4/axialRes);
            yBottom = nanmin(yBottom1,yBottom2);
            
            if ~isempty(foveaParams.Index)
                range = foveaParams.Range(1):foveaParams.Index;
                yFovea = layers(3,foveaParams.Index) - round(13.4/axialRes);
                thickness = 0:length(range)-1;
                thickness = round((yFovea-yTop(range(1)))/length(range) * thickness);
                yTop(range) = yTop(range(1)) + thickness;
                
                range = foveaParams.Index:foveaParams.Range(2);
                yFovea = layers(3,foveaParams.Index) - round(13.4/axialRes);
                thickness = 0:length(range)-1;
                thickness = round((yTop(range(end))-yFovea)/length(range) * thickness);
                yTop(range) = yFovea + thickness;
            end

        % cut 
        case {2}
            yTop = layers(1,:);
            yBottom = layers(3,:) - round(26.8/axialRes);

            if ~isempty(foveaParams.Index)
                range = foveaParams.Range(1):foveaParams.Range(2);
                yBottom(range) = layers(1,range) + round(20.1/axialRes);

                if eye == 1
                    thinRange = range(end):imageWidth;
                    thickRange = 1:range(1);
                elseif eye == 2
                    thinRange = 1:range(1);
                    thickRange = range(end):imageWidth;
                end
                thickness = 0:length(thickRange)-1;
                thickness = round(round(33.5/axialRes) / length(thickRange) * thickness);
                yTop(thickRange) = yTop(thickRange) + thickness;
                yBottom(thickRange) = layers(3,thickRange) - fliplr(thickness);
                yBottom(thinRange) = yTop(thinRange) + round(26.8/axialRes);
                
                correctBottomLine = 1;
            else
                range = 1:imageWidth;
                if eye == 1
                    range = fliplr(range);
                end
                thickness = 0:length(range)-1;
                thickness = round(round(13.4/axialRes) / length(range) * thickness);
                yTop(range) = yTop(range) + thickness;
            end
            
        otherwise
            error('Segmentation of layer %d is not supported', layerNumber);
    end

    
    %----------------------------------------------------------------------
    %  Handle cases where the input layer is NaN or empty.
    %----------------------------------------------------------------------
 
    nanIndices = isnan(yTop);   
    if sum(nanIndices) > 0
        yTop(nanIndices) = ones(1,sum(nanIndices));
    end
    
    nanIndices = isnan(yBottom);   
    if sum(nanIndices) > 0
        yBottom(nanIndices) = imageHeight*ones(1,sum(nanIndices));
    end


    %----------------------------------------------------------------------
    %  Make the region smaller with respect to the selected minimum 
    %  distance between lines
    %----------------------------------------------------------------------

    regionIndices = getRegion( ...
        imageSize, ...
        yTop, ...
        yBottom, ...
        topLayerAddition, ...
        bottomLayerAddition, ...
        [], ...
        correctBottomLine);
end