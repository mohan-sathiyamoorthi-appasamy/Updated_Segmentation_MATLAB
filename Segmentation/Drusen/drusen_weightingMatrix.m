%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  drusen_weightingMatrix.m
%
%  Generates the weighting matrices to be used for graph cut
%
%--------------------------------------------------------------------------
%
%  function weightingMatrices = drusen_weightingMatrix( ...
%      image, ...
%      axialRes, ...
%      lateralRes, ...
%      rpeTop, ...
%      rpeBottom, ...
%      matrixIndices, ...
%      params)
%
%  INPUT PARAMETERS:
%
%       image - Image to generate adjacency matrix for
%
%       axialRes - Axial (vertical) resolution of the image in um/pixel
%
%       lateralRes - Lateral (horizontal) resoution of the image in
%
%       rpeTop - A vector of size (1 x imageWidth) estimating the location
%                of the inner aspect of the RPE, generated by the
%                drusen_getBwImage() function
%
%       rpeBottom - A vector of size (1 x imageWidth) estimating the 
%                   location of the outer aspect of the RPE, generated by
%                   the drusen_getBwImage() function
%
%       matrixIndices - (Optional)Indices of the matrices to generate the 
%                       adjacency matrix for if not all need to be created
%
%       params - (Optional) WeightingMatrixParameters object containing 
%                 all of the constants used in this function.  Default 
%                 values are set by drusen_getParameters();
%
%  RETURN VARIABLES:
%
%       weightingMatrices - Array of weighting matrices to be used on
%                           particular layers, as defined by the
%                           WeightingMatrixType class
%
%--------------------------------------------------------------------------
%
%  Author:          Stephanie Chiu
%  Institution:     Duke University
%  Date Created:    2009.05.22
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


function weightingMatrices = drusen_weightingMatrix( ...
    image, ...
    axialRes, ...
    lateralRes, ...
    rpeTop, ...
    rpeBottom, ...
    matrixIndices, ...
    params)

    %----------------------------------------------------------------------
    %  Initialize missing input parameters
    %----------------------------------------------------------------------
    
    if nargin < 6
        matrixIndices = [];
    end
    
    if nargin < 7
        params = [];
    end

    %----------------------------------------------------------------------
    %  Validate input parameters
    %----------------------------------------------------------------------
    
    if isempty(matrixIndices)
        params = drusen_getParameters();
        params = params.graphCutParams.weightingMatrixParams;
    end
    
    nMatrices = length(params.WEIGHT_RANGES);
    
    if ~isempty(matrixIndices)
        matrixIndices(matrixIndices < 1) = [];
        matrixIndices(matrixIndices > nMatrices) = [];
    end
    if isempty(matrixIndices)
        matrixIndices = 1:nMatrices;
    end   

    imageSize = size(image);
    imageHeight = imageSize(1);
    imageWidth = imageSize(2);
    
   
    %----------------------------------------------------------------------
    %  Separate the vertical weights on the leftmost and rightmost columns
    %  from the rest of the weights in the image
    %----------------------------------------------------------------------
    
    %
    %  Generate edges and points on the image
    %
    edges = createLattice(imageSize);
    
    %
    %  Separate the edges corresponding to the left-most and right-most
    %  columns that were artificially added to the image
    %
    maxIndex = imageHeight*imageWidth;
    leftColIndices = 1:(imageHeight-1);
    rightColIndices = ((imageHeight-1)*(imageWidth-1) + 1) : maxIndex;
    
    columnIndices = [leftColIndices, rightColIndices];
    imageIndices = setdiff(1:size(edges,1), columnIndices);
    
    columnEdges = edges(columnIndices,:);
    imageEdges = edges(imageIndices,:);
    
    
    %----------------------------------------------------------------------
    %  Calculate the weights based on the image gradient.  Lower weights 
    %  are assigned to areas with a higher gradient
    %----------------------------------------------------------------------
    
    %
    %  Filter the image
    %
    xFilterSize = round(params.X_FILTER_SIZE / lateralRes);
    yFilterSize = round(params.Y_FILTER_SIZE / axialRes);
    filter = fspecial('gaussian',[yFilterSize,xFilterSize],params.SIGMA);   
    smoothImage = blurImage(image,filter);
    
    yFilterSize = round(6.7 / axialRes); 
    filter = fspecial('gaussian',[yFilterSize,xFilterSize],params.SIGMA);
    smoothImage_ga = blurImage(image,filter);
    
    %
    %  Create two edge maps (one for edges that transition from dark->light
    %  in the vertical direction, and one for edges transitioning from 
    %  light->dark).  
    %
    lightDarkEdgeImage = ...
        (blurImage(smoothImage, -params.EDGE_FILTER) > 0) .* ...
         blurImage(smoothImage, -params.EDGE_FILTER);
                     
    darkLightEdgeImage = ...
        (blurImage(smoothImage, params.EDGE_FILTER) > 0) .* ...
         blurImage(smoothImage, params.EDGE_FILTER);     
     
    lightDarkEdgeImage_ga = ...
        (blurImage(smoothImage_ga, -params.EDGE_FILTER) > 0) .* ...
         blurImage(smoothImage_ga, -params.EDGE_FILTER);
                     
    darkLightEdgeImage_ga = ...
        (blurImage(smoothImage_ga, params.EDGE_FILTER) > 0) .* ...
         blurImage(smoothImage_ga, params.EDGE_FILTER);  

    lightDarkEdgeImage = normalizeValues(lightDarkEdgeImage,0,1);  
    lightDarkEdgeImage_ga = normalizeValues(lightDarkEdgeImage_ga,0,1);  
    darkLightEdgeImage = normalizeValues(darkLightEdgeImage,0,1);  
    darkLightEdgeImage_ga = normalizeValues(darkLightEdgeImage_ga,0,1);
    
    
    % Make it difficult to cross the opposite gradient
    darkLightInd = (lightDarkEdgeImage > 0);
    lightDarkInd_ga = (darkLightEdgeImage_ga > 0);
    darkLightInd_ga = (lightDarkEdgeImage_ga > 0);
    
    darkLightEdgeImage(darkLightInd) = 0;
    lightDarkEdgeImage_ga(lightDarkInd_ga) = 0; 
    darkLightEdgeImage_ga(darkLightInd_ga) = 0;
    
    % Only keep the strongest gradient, removing consecutive gradient
    % values
    for iCol = 1:imageWidth
        column = darkLightEdgeImage(:,iCol);
        maxima = find(diff(sign(diff([0;column;0]))) < 0);
        darkLightEdgeImage(:,iCol) = 0;
        darkLightEdgeImage(maxima,iCol) = column(maxima);
        
        column = darkLightEdgeImage_ga(:,iCol);
        maxima = find(diff(sign(diff([0;column;0]))) < 0);
        darkLightEdgeImage_ga(:,iCol) = 0;
        darkLightEdgeImage_ga(maxima,iCol) = column(maxima);        
        if ~isnan(rpeTop(iCol)) && ~isnan(rpeBottom(iCol))
            maxima = maxima(maxima >= rpeTop(iCol) & maxima <= rpeBottom(iCol));
            darkLightEdgeImage_ga(maxima,iCol) = 1;
        end
        
        column = lightDarkEdgeImage_ga(:,iCol);
        maxima = find(diff(sign(diff([0;column;0]))) < 0);
        lightDarkEdgeImage_ga(:,iCol) = 0;
        lightDarkEdgeImage_ga(maxima,iCol) = column(maxima);
    end
    
    % Make it even more difficult to cross the opposite gradient
    darkLightEdgeImage(darkLightInd) = -1;
    darkLightEdgeImage_ga(darkLightInd_ga) = -1;
    lightDarkEdgeImage_ga(lightDarkInd_ga) = -1;
    
    %
    %  Calculate the gradient weights for each of the edge maps
    %        
    darkLightGradientWeights = 2 - ...
        darkLightEdgeImage(imageEdges(:,1)) - ...
        darkLightEdgeImage(imageEdges(:,2));
    
    darkLightGradientWeights_ga = 2 - ...
        darkLightEdgeImage_ga(imageEdges(:,1)) - ...
        darkLightEdgeImage_ga(imageEdges(:,2));
    
    lightDarkGradientWeights_ga = 2 - ...
        lightDarkEdgeImage_ga(imageEdges(:,1)) - ...
        lightDarkEdgeImage_ga(imageEdges(:,2));
    
    
    %----------------------------------------------------------------------
    %  Calculate intensity weights
    %----------------------------------------------------------------------
    
    brightIntensityWeights = - smoothImage(imageEdges(:,1)) ...
                             - smoothImage(imageEdges(:,2));
    
                     
    %----------------------------------------------------------------------
    %  Calculate the geometric distances between pairs of points.  Lower
    %  weights go to pixel pairs that are closer together
    %----------------------------------------------------------------------
    
    [yFirstPoint, xFirstPoint] = ind2sub(imageSize, imageEdges(:,1));
    [ySecondPoint, xSecondPoint] = ind2sub(imageSize, imageEdges(:,2));
    
    distanceWeights = sqrt( ...
        (xFirstPoint - xSecondPoint).^2 + (yFirstPoint - ySecondPoint).^2);
     
    
    %----------------------------------------------------------------------
    %  Create a weighting matrix. Rows represent the indices of the first
    %  node and columns represent the indices of the second node.  The 
    %  values represent the weights for the edge that is formed between
    %  the two nodes
    %----------------------------------------------------------------------

    % Define the matrices  
    weights = { ...
        {darkLightGradientWeights}, ...                                                % dark-light weights
        {darkLightGradientWeights_ga}, ...                                             % dark-light weights for GA
        {lightDarkGradientWeights_ga, darkLightGradientWeights, distanceWeights}, ...  % light-dark, dark-light, short weights
        {brightIntensityWeights}, ...                                                  % bright intensity weights
    };
    nMatrices = length(weights);   
    
    % Set default weight ranges if necessary 
    if isempty(params.WEIGHT_RANGES)
        params.WEIGHT_RANGES = { ...
            {[0,1]}, ...              % dark-light weights
            {[0,1]}, ...              % dark-light weights for GA
            {[0,1],[0,1],[0,1]}, ...  % light-dark, dark-light, short weights
            {[0,1]}, ...              % bright intensity weights
        };
    end
    
    % Remove invalid matrix indices
    matrixIndices(matrixIndices < 1) = [];
    matrixIndices(matrixIndices > nMatrices) = [];
    if isempty(matrixIndices)
        matrixIndices = 1:nMatrices;
    end
    
    % Populate the matrices specified
    weightingMatrices = cell(nMatrices,1);
    matrixSize = maxIndex;
    
    for iMatrix = 1:length(matrixIndices)
        
        matrixIndex = matrixIndices(iMatrix);
        
        weightingMatrices{matrixIndex} = generateWeightingMatrix( ...
            matrixSize, ...
            imageEdges, ...
            weights{matrixIndex}, ...
            params.WEIGHT_RANGES{matrixIndex}, ...
            columnEdges, ...
            params.MIN_WEIGHT);
    end
end